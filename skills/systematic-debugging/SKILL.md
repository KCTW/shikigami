---
name: systematic-debugging
description: "Use when encountering bugs, test failures, or unexpected behavior - 系統化除錯流程"
---

# Systematic Debugging — 系統化除錯

## 1. 概述

遇到 bug、測試失敗、非預期行為時的標準除錯流程。由 **Developer subagent** 主導除錯，**QA subagent** 驗證修復。

核心原則：**禁止猜測性修復，必須有根因調查。**

---

## 2. 核心原則（Iron Law）

```
沒有根因調查，不得提出修復方案。
```

- **先觀察再假設，先假設再動手**：未充分蒐集證據前，不得跳入修復階段。
- **每次只改一個變數**：同時修改多處會使因果關係無法釐清。
- **用 git stash 保護現場**：動手前先保存當前工作狀態，確保可隨時還原。
- **禁止「猜測性修復」**：每一個修復動作都必須有證據支持，不得憑直覺嘗試。

---

## 3. 四階段流程

### Phase 1: 根因調查

```
1. 仔細閱讀錯誤訊息（不跳過 stack trace）
   |
   v
2. 穩定重現問題（記錄精確步驟）
   |
   v
3. 檢查近期變更（git diff, recent commits）
   |
   v
4. 多元件系統：在每個元件邊界加診斷 log
   |
   v
5. 追蹤資料流：從壞值往回追到源頭
```

**Phase 1 詳解**：

1. **閱讀錯誤訊息**：完整閱讀 error message 與 stack trace，不可僅看第一行就跳過。Stack trace 中的每一層呼叫都是線索。
2. **穩定重現**：找到可 100% 重現問題的精確步驟。無法穩定重現的 bug 不可直接進入修復階段。
3. **檢查近期變更**：使用 `git diff`、`git log` 檢查近期的 commit，確認問題是否由最近的變更引入。
4. **元件邊界診斷**：在微服務或多模組架構中，於每個元件的輸入/輸出點加入診斷 log，縮小問題範圍。
5. **資料流追蹤**：從觀察到的錯誤值（壞值）往回追溯，找到資料最初被汙染或錯誤產生的源頭。

### Phase 2: 模式分析

1. **找到可運作的類似代碼**：在 codebase 中搜尋功能相似但正常運作的代碼片段。
2. **比較差異**：將問題代碼與正常代碼逐項比對，列出所有差異。
3. **理解依賴關係**：釐清問題代碼所依賴的模組、服務、設定，確認是否有依賴層的異常。

### Phase 3: 假設與驗證

```
形成假設 → 最小變更測試 → 驗證結果
    ^                         |
    |     未通過：新假設       |
    +-------------------------+
    |     通過：進入 Phase 4   |
    +-------------------------→ Phase 4
```

1. **形成單一假設**：明確陳述「我認為 X 是根因，因為 Y」，假設必須具備可證偽性。
2. **最小變更測試**：一次只改一個變數，執行測試驗證假設。
3. **判定結果**：
   - 驗證通過 → 進入 Phase 4
   - 驗證未通過 → 回到步驟 1，形成新假設

### Phase 4: 實作修復

1. **先寫失敗測試（TDD）**：撰寫一個能重現 bug 的測試案例，確認測試在修復前為失敗狀態。
2. **實作單一修復**：只修根因，不做額外的「順手改進」。修復範圍必須與根因調查結果一致。
3. **驗證通過 + 無回歸**：確認失敗測試轉為通過，且既有測試套件全部通過、無新增回歸。

---

## 4. Hard Gates

<HARD-GATE>
未完成 Phase 1 根因調查，不得提出修復方案。
</HARD-GATE>

<HARD-GATE>
連續修復失敗 3 次，必須升級至 Architect 評估是否為架構問題。
不得嘗試第 4 次修復。
</HARD-GATE>

---

## 5. Red Flags

以下念頭出現時，代表你正在偏離系統化除錯流程。**立即停止，返回 Phase 1。**

| Red Flag 念頭 | 正確做法 |
|----------------|----------|
| 「快速修一下就好，之後再查」 | STOP — 返回 Phase 1，先完成根因調查 |
| 「試試改 X 看會不會好」 | STOP — 這是猜測性修復，必須先有假設與證據 |
| 「同時改多個地方，跑測試」 | STOP — 每次只改一個變數，否則無法釐清因果 |
| 「跳過測試，手動驗證」 | STOP — 必須有自動化測試證明修復有效 |
| 「大概是 X 的問題，先修那個」 | STOP — 「大概」不是證據，回到 Phase 1 蒐集證據 |
| 「我不完全理解，但這樣可能可以」 | STOP — 不理解根因就不該動手修復 |
| 「再試一次修復」（已失敗 2+ 次時） | STOP — 觸發 Hard Gate，升級至 Architect 評估 |

---

## 6. Subagent 派遣

```
1. Developer subagent → 執行 Phase 1-4 除錯流程
2. QA subagent       → 驗證修復（Spec Compliance + Code Quality）
3. 如為架構問題      → Architect subagent 評估
```

**派遣說明**：

1. **Developer subagent（主導）**：執行完整的四階段除錯流程。從根因調查開始，經過模式分析與假設驗證，最終實作修復。Developer 必須在每個階段產出明確的調查紀錄。
2. **QA subagent（驗證）**：Developer 完成修復後，QA subagent 進行驗證。驗證範圍包含：修復是否符合規格（Spec Compliance）、代碼品質是否達標（Code Quality）、是否產生回歸。
3. **Architect subagent（升級）**：當連續修復失敗 3 次、或根因調查發現問題源於架構設計時，升級至 Architect 評估。Architect 需判斷是否需要架構層面的調整。

---

## 7. 與其他 Skill 的關係

| 情境 | 觸發 |
|------|------|
| 修復完成 | 走 `quality-gate` 驗證 |
| 發現架構問題 | 觸發 `architecture-decision` |
| 需要安全修復 | 觸發 `security-review` |
| Sprint 中的 Bug | 更新 PROJECT_BOARD，回到 `sprint-execution` |
